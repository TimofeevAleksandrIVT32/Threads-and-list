#include <stdio.h>
#include <pthread.h>
#include <malloc.h>
#include <locale.h>
#include "threads.h"

extern pthread_mutex_t mutex;
extern int flag;

//функция для запуска в потоке
void *fun_for_threads(void *arg) {
    struct list *cur; //указатель на текущий элемент
    struct list *del; //указатель на удаляемый элемент
    int sum = 0; //переменная для подсчета количества нулей или единиц элементов, обработанных потоком
    int buff = 0; //переменная, в которую записывается количество единиц элемента потока
    int count = 0; //счетчик элементов, обработанных потоком
    struct list_args *a = (struct list_args*)arg; //принимаем указатели на начало и конец списка, а также направление обхода потока
    if (a->direction == 0) { //если направление 0
    	cur = a->head; //то начинаем с начала списка
    }
    else { //если направление 1
    	cur = a->tail; //то начинаем с конца списка
    }
    do {
        pthread_mutex_lock(&mutex); //блокируем мьютекс, так как мы не можем допустить, чтобы два потока одновременно работали с flag и элементами списка
        if (flag == 1) { //если flag выставлен в единицу, значит другой поток уже обработал последний элемент списка
            pthread_mutex_unlock(&mutex); //освобождаем мьютекс
            break; //выходим из цикла обработки потока
        }
        while(cur->data) {
            if(cur->data % 10 == 1) { //подсчитываем количество 1
                buff++;
            }
            cur->data /= 10;
        }
        del = cur;
        if (a->direction == 0){ //в зависимости от направления переходим на следующий или предыдущий элемент
            cur = cur->next;
        }
        else {
            cur = cur->prev;
        }
        //если не последний оставшийся в списке элемент, то очищаем память, занятую элементом
        if (cur != NULL){
            if (a->direction == 0){ //в зависимости от направления удаляем указатель на следующий или предыдущий элемент списка
                cur->prev = NULL;
            }
            else{
                cur->next = NULL;
            }
            free(del); //освобождаем память
            pthread_mutex_unlock(&mutex);
        }
        //если последний элемент
        else {
            if (flag == 0) { //если flag==0, значит видим элемент первый раз, следовательно выставляем флаг в 1 и очищаем последний элемент
                flag = 1;
		        free (del);
                pthread_mutex_unlock(&mutex);
		    }
        }
        if (a->direction == 0) { //если направление 0, значит нужно посчитать количество нулей
            sum += 10 - buff; //вычитаем количество единиц из 10, так как числа от 0 то 1000, т.е. не больше 10 разрядов в 2 системе; прибавляем к sum
        }
        else {
            sum += buff; //при направлении 1 прибавляем к sum количество единиц
        }
        buff = 0;
        count++; //прибавлем счетчик, так как обработали элемент
    } while (1); //так как цикл завершается после выставления флага в 1, нам не требуется условие выхода из цикла
    pthread_mutex_lock(&mutex);
    printf ("Поток id: %lu\n", pthread_self());
    printf ("Количество обработанных элементов: %d\n", count);
    if (a->direction == 0) {
        printf ("Количество нулевых битов: %d\n", sum);
    }
    if (a->direction == 1) {
        printf ("Количество единичных битов: %d\n", sum);
    }
    printf("\n");
    pthread_mutex_unlock(&mutex);
}
